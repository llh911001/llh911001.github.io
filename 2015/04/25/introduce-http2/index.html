<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HTTP/2 简介 | Hackll.com</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="5/15/2015 更新HTTP/2 协议标准已经敲定了，是为 RFC7540。
1. HTTP 现状HTTP 是现在互联网上使用最广泛的网络协议，它的当前版本是 HTTP/1.1，也是使用范围最广的版本（实际上还有不少的代理服务器在使用 HTTP/1.0）。HTTP 的标准由 IETF 和 W3C 共同负责制定，HTTP/1.1 的最初版本于 1997 年 7 月发布，即 RFC 2068。随后">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP/2 简介">
<meta property="og:url" content="http://hackll.com/2015/04/25/introduce-http2/index.html">
<meta property="og:site_name" content="Hackll.com">
<meta property="og:description" content="5/15/2015 更新HTTP/2 协议标准已经敲定了，是为 RFC7540。
1. HTTP 现状HTTP 是现在互联网上使用最广泛的网络协议，它的当前版本是 HTTP/1.1，也是使用范围最广的版本（实际上还有不少的代理服务器在使用 HTTP/1.0）。HTTP 的标准由 IETF 和 W3C 共同负责制定，HTTP/1.1 的最初版本于 1997 年 7 月发布，即 RFC 2068。随后">
<meta property="og:image" content="http://7xir1p.com1.z0.glb.clouddn.com/chart.png">
<meta property="og:image" content="http://7xir1p.com1.z0.glb.clouddn.com/hpbn_1202.png">
<meta property="og:image" content="http://7xir1p.com1.z0.glb.clouddn.com/caniuse-http2.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP/2 简介">
<meta name="twitter:description" content="5/15/2015 更新HTTP/2 协议标准已经敲定了，是为 RFC7540。
1. HTTP 现状HTTP 是现在互联网上使用最广泛的网络协议，它的当前版本是 HTTP/1.1，也是使用范围最广的版本（实际上还有不少的代理服务器在使用 HTTP/1.0）。HTTP 的标准由 IETF 和 W3C 共同负责制定，HTTP/1.1 的最初版本于 1997 年 7 月发布，即 RFC 2068。随后">
<meta name="twitter:creator" content="@lilh42">
<link rel="publisher" href="u/0/108755916357635545032">
  
  
    <link rel="icon" href="/favicon.ico">
    <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <style type="text/css">
html {background-color: white}</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      
  <header id="header" class="small">

  <div id="header-inner" class="">
    <a class="title"><h1>Hackll.com</h1></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
      </a>
    </nav>
    <nav id="sub-nav">
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://hackll.com"></form>
    </div>
  </div>
</header>

      <aside id="sidebar">
  <div id="site-info" class="inner">
    <div id="logo-wrap" class="sidebar-item">
      <div id="logo"></div>
    </div>
    
    <div id="social-wrap" class="clearfix sidebar-item">
    
      <div class="social-item">
        <a id="nav-twitter-link" class="nav-icon" href="https://twitter.com/lilh42" title="Twitter" target="_blank"></a>
      </div>
    
    
      <div class="social-item">
        <a id="nav-github-link" class="nav-icon" href="https://github.com/llh911001" title="Github" target="_blank"></a>
      </div>
    
    
      <div class="social-item">
        <a id="nav-gplus-link" class="nav-icon" href="https://plus.google.com/u/0/108755916357635545032" title="Google plus" target="_blank"></a>
      </div>
    
    
    </div>
    <div class="site-nav sidebar-item">
      <ul>
      
        <li>
          <a href="/">Home</a>
        </li>
      
        <li>
          <a href="/archives">Archives</a>
        </li>
      
        <li>
          <a href="/about">About</a>
        </li>
      
      </ul>
    </div>
  </div>
</aside>

      <div class="outer">
        <section id="main"><article id="post-introduce-http2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HTTP/2 简介
    </h1>
  


        <div class="article-meta">
          
  <time class="centered" datetime="2015-04-24T16:00:00.000Z" itemprop="datePublished">04/25/2015</time>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5/15/2015_更新">5/15/2015 更新</h2><p>HTTP/2 协议标准已经敲定了，是为 <a href="http://www.rfc-editor.org/rfc/rfc7540.txt" target="_blank" rel="external">RFC7540</a>。</p>
<h2 id="1-_HTTP_现状">1. HTTP 现状</h2><p>HTTP 是现在互联网上使用最广泛的网络协议，它的当前版本是 HTTP/1.1，也是使用范围最广的版本（实际上还有不少的<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#HTTP.2F1.0" target="_blank" rel="external">代理服务器</a>在使用 HTTP/1.0）。HTTP 的标准由 <a href="http://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" target="_blank" rel="external">IETF</a> 和 <a href="http://en.wikipedia.org/wiki/World_Wide_Web_Consortium" target="_blank" rel="external">W3C</a> 共同负责制定，HTTP/1.1 的最初版本于 1997 年 7 月发布，即 <a href="http://tools.ietf.org/html/rfc2068" target="_blank" rel="external">RFC 2068</a>。随后在 1999 年 6 月，他们又发布了 <a href="http://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC 2616</a>，主要针对 <a href="http://tools.ietf.org/html/rfc2068" target="_blank" rel="external">RFC 2068</a> 进行一些修订和改善。2014 年 7 月，<a href="http://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC 2616</a> 更新为 <a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="external">RFC 7230</a> 等六个 <a href="http://en.wikipedia.org/wiki/Request_for_Comments" target="_blank" rel="external">RFC</a> 标准。</p>
<h3 id="1-1_传输量和请求数">1.1 传输量和请求数</h3><p>随着前端技术的发展，包括 JavaScript 层出不穷的框架和类库，以及越来越成熟的构建工具和模块化开发等等，导致网页上需要展现的内容及加载一个页面所需的请求数越来越多，而这一趋势，短期来看，并无扭转的可能。</p>
<p>下图展示了从 2011 年 4 月到 2015 年 4 月网页的平均传输量和请求数，可以看到，现在用户打开一个网页需要下载的资源已经达到将近 2MB，请求数也接近 100。（数据来源：<a href="http://httparchive.org" target="_blank" rel="external">httparchive.org</a>）</p>
<a id="more"></a>
<p><img src="http://7xir1p.com1.z0.glb.clouddn.com/chart.png" alt="2011-2015"></p>
<h3 id="1-2_HTTP/1-1_的缺点">1.2 HTTP/1.1 的缺点</h3><p>越来越多的资源和请求，意味着越来越高的延时。即便带宽和网速节节升高，其对延时的改善也收效甚微：HTTP 的实现在事实上造成的结果是，一个 <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="external">TCP</a> 连接中只允许有一个<strong>主要</strong>的请求。这是因为，HTTP/1.1 要求服务器按照它接收到的请求的顺序发送响应。也就是说，这种连接遵循的是<a href="http://en.wikipedia.org/wiki/FIFO_(computing_and_electronics" target="_blank" rel="external">先进先出</a>原则。显然，如果有一个请求非常耗时，那么后续请求都将受到影响，所以这就造成了 <a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="external">Head-of-line blocking</a> 问题。</p>
<p>在过去，浏览器曾经使用多个 TCP 连接来分发并行请求，但这种方式实在是弊大于利。如果页面中请求数过多，那么不但有可能触发 TCP 的拥塞从而降低性能，而且过多的请求也意味着传输大量的重复数据。</p>
<p>HTTP/1.1 试图解决性能问题的另一种手段是 <a href="http://en.wikipedia.org/wiki/HTTP_pipelining" target="_blank" rel="external">HTTP Pipelining</a>。这种技术把多个 HTTP 请求打包在一个 TCP 连接中一次性地发送，而在发送过程中不需等待服务器对上一个请求的响应。看起来，这像是一个「异步」操作，而且能够降低 TCP 连接数。事实上，对于一些本来就高延时的连接，这种方式确实能够显著降低延时。但对于网络带宽很充裕的连接，效果就不那么明显了。因此这无法从根本上解决 <a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="external">Head-of-line blocking</a>。</p>
<p>而且，<a href="http://en.wikipedia.org/wiki/HTTP_pipelining" target="_blank" rel="external">HTTP Pipelining</a> 要求服务器和浏览器都支持才可行。更严格的是，只有<a href="http://restcookbook.com/HTTP%20Methods/idempotency/" target="_blank" rel="external">幂等请求</a>，也就是 <code>HEAD</code> 和 <code>GET</code> 才可以 pipelining，非幂等请求如 <code>POST</code> 和 <code>PUT</code> 是不可以 pipelining 的。因此直到今天，主流浏览器的 HTTP Pipelining 开关还是默认关闭的。</p>
<p>面对上述残酷的事实，机智的 Web 开发者们发明出了不少变通方案，例如 <a href="http://calendar.perfplanet.com/2011/why-inlining-everything-is-not-the-answer/" target="_blank" rel="external">inlining</a>，<a href="http://www.yottaa.com/blog/application-optimization/bid/259514/How-Does-Reducing-JavaScript-Requests-Minifying-JavaScript-" target="_blank" rel="external">concatenation</a>，<a href="http://css-tricks.com/css-sprites/" target="_blank" rel="external">spriting</a> 等技术来减少页面请求从而优化性能。当然这些变通方案有利有弊，个中取舍，端看开发者的业务和需求。</p>
<h2 id="2-_HTTP/2_的主要特点">2. HTTP/2 的主要特点</h2><p>既然当前 Web 应用的性能和体验问题严重受限于 HTTP/1.1，那与其想办法减少请求或者降低负载，还不如从根源上解决问题：修订 HTTP 协议。毕竟，当前互联网上不可或缺的这个协议，其标准的制定距今已经 15 年了。</p>
<p>其实早在 2007 年，<a href="http://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" target="_blank" rel="external">IETF</a> 就组织成立了 <a href="https://httpwg.github.io/" target="_blank" rel="external">HTTP Working Group</a> 着手修订 HTTP/1.1。2012 年底，当他们真正开始起草 HTTP 2.0 的时候，发现 Google 已经有一个证实可行的 <a href="http://en.wikipedia.org/wiki/SPDY" target="_blank" rel="external">SPDY</a> 了！于是 HTTP 2.0 就在 <a href="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00" target="_blank" rel="external">SPDY/2</a> 草案的基础上实现了第一个草案：HTTP2 draft-00。之后他们又进行了一些修修补补的工作，并顺便把协议的新版本叫做 HTTP/2，去掉了 “.0”。2015 年 2 月 17 日，<a href="http://en.wikipedia.org/wiki/Internet_Engineering_Steering_Group" target="_blank" rel="external">IESG</a> 接受 HTTP/2 为 <a href="http://en.wikipedia.org/wiki/Internet_Standard#Proposed_Standard" target="_blank" rel="external">Proposed Standard</a>。</p>
<p>虽然，HTTP/2 的目标是成为 HTTP 的「下一个」版本，但无论是理论上，还是现实中，都无法在 API 或者「语法」层面修改 HTTP 协议。制定 HTTP/2 标准，一些原则和限制还是坚持和遵守的：</p>
<ol>
<li>协议层面上保持不变，请求还是通过 TCP 传送；</li>
<li>URL scheme，即 <code>http://</code> 和 <code>https://</code> 保持不变；</li>
<li>保持向后兼容，能够与 HTTP/1.x 服务器（包括代理服务器）正常通讯；</li>
<li>不再制定子版本，如果协议再有更新，则为 HTTP/3。</li>
</ol>
<h3 id="2-1_二进制（Binary）">2.1 二进制（Binary）</h3><p>HTTP/2 传输的数据是二进制的。相比 HTTP/1.1 的纯文本数据，二进制数据一个显而易见的好处是：更小的传输体积。这就意味着更低的负载。二进制的帧也更易于解析而且不易出错，纯文本帧在解析的时候还要考虑处理空格、大小写、空行和换行等问题，而二进制帧就不存在这个问题。</p>
<p>在 HTTP/2 的语境下，有三个概念需要厘清，它们就是：流（Stream）、消息（Message） 和帧（Frame）。</p>
<p><strong>Stream</strong><br>处于一个连接中的双向二进制数据流，可以包含一个或者多个 <code>Message</code>。</p>
<p><strong>Message</strong><br>一个完整的请求或者响应，包含多个 <code>Frame</code> 序列。</p>
<p><strong>Frame</strong><br>HTTP/2 通讯中的最小传输单位，至少含有一个 <code>Frame header</code>，能够表示它属于哪一个 <code>Stream</code>。</p>
<p>如下图所示（题图来源：<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch12.html#_design_and_technical_goals" target="_blank" rel="external">High Performance Browser Networking</a>）：<br><img src="http://7xir1p.com1.z0.glb.clouddn.com/hpbn_1202.png" alt="Stream, Message and Frame"></p>
<h3 id="2-2_多路复用（Multiplexing）">2.2 多路复用（Multiplexing）</h3><p>之前提到，HTTP/1.1 存在 <a href="http://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="external">Head-of-line blocking</a> 问题，多路复用就是用来解决这个问题的。</p>
<p>所谓多路复用，简单来说，就是允许一个 TCP 连接中能够同时发送多个 HTTP 请求，而且请求与响应完全是异步的，耗时长的请求/响应不会阻塞其他请求/响应。具体点讲就是，服务器和客户端都可以把 HTTP 消息分割成多个独立的二进制帧，每一个帧都有一个 <code>Stream ID</code> 标示它所在的流，而这些帧可以插入到流中的任意一个位置（即帧的传送顺序不重要），到达目的地之后，接收端再把收到的帧「组装」起来。</p>
<p>另外，每一个流还有优先级和依赖（Priorities and dependencies），意味着客户端可以指定哪些流是最重要的需要优先传送，哪些流又依赖其他的流从而提供这个依赖参数。</p>
<p>我们知道，建立 TCP 连接的开销非常大，当前存在的一些优化性能的变通方法，归根结底是要减少请求和连接数。多路复用让这些「奇技淫巧」存在的价值大大降低，甚至不再必要。</p>
<h3 id="2-3_头部压缩（Header_compression）">2.3 头部压缩（Header compression）</h3><p>HTTP 是无状态的协议，HTTP/2 也保留了这一点。因此 HTTP 请求的头部需要包含用于标识身份的数据比如 <code>cookies</code>，而这些数据的量也在随着时间增长。每一个请求的头部都包含这些大量的重复数据，无疑是一种很大的负担。对请求头部进行压缩，将会大大减轻这种负担，尤其对移动端来说，性能提高非常明显。</p>
<p>HTTP/2 使用的压缩方式是 <a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09" target="_blank" rel="external">HPACK</a>。</p>
<h3 id="2-4_重置（Reset）">2.4 重置（Reset）</h3><p>在 HTTP/1.1 中，如果客户端决定要中断一个请求，那它非要打开一个新的 TCP 连接告诉服务器不可。这种方式不但浪费带宽，而且可能会带来其他的麻烦。</p>
<p>HTTP/2 引入了一个 <a href="http://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM frame</a> 来让客户端在已有的连接中发送重置请求，从而中断或者放弃响应。</p>
<h3 id="2-5_服务器推送（Server_push）">2.5 服务器推送（Server push）</h3><p>HTTP/2 的服务器推送所作的工作就是，服务器在收到客户端对某个资源的请求时，会判断客户端十有八九还要请求其他的什么资源，然后一同把这些资源都发送给客户端，即便客户端还没有明确表示它需要这些资源。</p>
<p>客户端可以选择把额外的资源放入缓存中（所以这个特点也叫 Cache push），也可以选择发送一个 RST_STREAM frame 拒绝任何它不想要的资源。</p>
<h3 id="2-6_加密（Encryption）">2.6 加密（Encryption）</h3><p>HTTP/2 并<a href="https://www.mnot.net/blog/2014/01/04/strengthening_http_a_personal_view" target="_blank" rel="external">不强制要求使用 TLS</a>，但 Chrome 和 Firefox 都声明他们只支持基于 TLS 的实现，这有可能会让加密成为事实上强制的规范。</p>
<h2 id="3-_目前的实现">3. 目前的实现</h2><p>在浏览器端，目前主流浏览器对 HTTP/2 的支持程度如下（数据来源：<a href="http://caniuse.com/#search=http2" target="_blank" rel="external">Can I Use</a>）：<br><img src="http://7xir1p.com1.z0.glb.clouddn.com/caniuse-http2.png" alt="caniuse-htt2"></p>
<p>如果想在 Firefox 浏览器里体验 HTTP/2，可以参看<a href="http://http2-explained.readthedocs.org/en/latest/src/http2firefox.html" target="_blank" rel="external">这里</a>。</p>
<p>服务器端也有不少的实现，比如 <a href="https://google.com" target="_blank" rel="external">Google</a> 和 <a href="https://twitter.com" target="_blank" rel="external">Twitter</a> 都已经提供了 HTTP/2 的测试服务器。完整的实现列表可以参看<a href="https://github.com/http2/http2-spec/wiki/Implementations" target="_blank" rel="external">这里</a>。</p>
<h2 id="参考链接">参考链接</h2><ol>
<li><a href="https://http2.github.io/faq/" target="_blank" rel="external">HTTP/2 Frequently Asked Questions</a>  </li>
<li><a href="http://http2-explained.readthedocs.org/en/latest/index.html" target="_blank" rel="external">http2-explained</a>  </li>
<li><a href="https://www.mnot.net/blog/2014/01/30/http2_expectations" target="_blank" rel="external">Nine Things to Expect from HTTP/2</a>  </li>
<li><a href="http://chimera.labs.oreilly.com/books/1230000000545" target="_blank" rel="external">High Performance Browser Networking</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hackll.com/2015/04/25/introduce-http2/" data-id="ci8y9lnxd0000liqf79ey08sc" class="article-share-link">Share</a>
      
        <a href="http://hackll.com/2015/04/25/introduce-http2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP2/">HTTP2</a></li></ul>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/05/15/todomvc-with-es6-and-jspm/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Previous</strong>
      <div class="article-nav-title">
        
          Todomvc with ES6 and jspm
        
      </div>
    </a>
  
  
    <a href="/2015/04/12/20-vim-tips/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Next</strong>
      <div class="article-nav-title">20 个 Vim 实用技巧</div>
    </a>
  
</nav>


  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Linghao Li<br>
      Powered by <a target="_blank" href="http://hexo.io">Hexo</a>, theme by <a target="_blank" href="https://github.com/llh911001/hexo-theme-lighting">Lighting</a>
    </div>
  </div>
</footer>

    </div>
    
<script>
  var disqus_shortname = 'linghaosblog';
  
  //var disqus_url = 'http://hackll.com/2015/04/25/introduce-http2/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="http://cdn.staticfile.org/scrollReveal.js/0.1.2/scrollReveal.min.js"></script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script>
  window.scrollReveal = new scrollReveal();
</script>

<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>
